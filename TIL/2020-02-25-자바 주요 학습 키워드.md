## 아래 주제에 대해 1) 책 없이 코딩 가능 2) 면접관에게 설명 또는 3) 서술형 답안을 완성할 수 있을 정도로 공부해 보자.

### 자바의 기본 자료형

### 단항 연산자 및 이항 연산자의 차이
- 단항 연산자는 피연산자가 1개인 연산자이다. 대표적으로 ++, --, 비트연산자 
- 이항 연산자는 피연산자가 2개인 연산자이다. 대표적으로 논리연산자 등이 있다.


### 변수의 스코프
스코프를 이해하기 위해선 memory 구조, byteCode에 대해 알아야 한다.

### JVM 메모리 모델, GC의 동작원리
자바 가상머신은 운영체제로 부터 메모리를 할당받는다. 이 메모리를 메서드 영역, 스택 영역, 힙 영역으로 나눠서 관리한다. 
- 메서드 영역은 실행되는 프로그램과 관련된 데이터가 저장된다. 예를 들어, byte code이다.
- 스택 영역은 스코프 내 지역 변수와 매개 변수를 저장하는 영역이다. 특징은 스코프가 끝나면(메서드가 종료되면) 함께 소멸된다. 
- 힙 영역은 인스턴스를 저장하는 영역이다. 만약 메서드 스코프 내 참조변수가 인스턴스를 가르키고 있다면 이 상황은 어떻게 저장될까? 참조변수는 스택영역에 있고 인스턴스는 힙에 저장된다. 그 인스턴스를 참조변수가 참조하는 상태이다. 인스턴스만 힙 영역에 저장하는 이유는 인스턴스의 소멸 시점과 소멸 방법이 지역 변수와 다르기 때문이다. GC가 참여한다. 

GC(Garbage Collection)는 힙 영역에 있는 인스턴스를 제거하는 것을 말한다. 언제 작동하느냐면 힙 영역 내 인스턴스 내 아무런 참조를 받지 않을 때 대상이 된다. 참조가 끊어졌다고 무조건 GC가 작동하는 것은 아니고 가상머신이 판단한다. 

### 메소드와 스코프
메소드는 객체가 책임을 수행하는 방법을 의미한다. 객체 지향 프로그래밍에서 객체들은 메세지로 소통하는데, 객체가 수신하는 메세지는 객체의 인터페이스를 의미한다. 인터페이스와 다르게 외부에 드러나지 않고 객체가 책임을 수행하기 위한 방법이 메서드이다.<br>
스코프는 메서드가 수행되는 코드상의 범위를 말한다. 지역 변수는 스코프라는 지역 내 선언된 변수를 의미하고 스코프를 벗어나면 지역변수는 활용할 수 없다.

### 접근 한정자
#### 접근 한정자란
접근 한정자(제어자)란 공용 인터페이스 외에는 외부에 노출하지 않는 객체가 어느정도 접근 허용하는 지를 나타내는 키워드이다. 원래 객체는 캡슐화가 되어 있기 때문에 객체 내부의 속성과 메서드는 객체 자신만 수정할 수 있다. 하지만 상황에 따라선 외부의 접근도 허용해야 하니 접근 한정자가 필요하다

#### 접근 제어자의 종류
- public : 모든 접근 허용
- protected : 같은 패키지 내 객체 접근 허용 및 상속 관계 객체 접근 허용, 패키지 접근 제한자라고도 한다.
- default : 같은 패키지 내 객체 접근 허용
- private : 객체 내부에서만 접근 허용

### 객체 지향 프로그래밍
객체지향 프로그래밍은 역할과 책임을 가진 객체 간의 협력으로 프로그래밍을 하는 패러다임이다. 객체 지향의 중심은 객체이다. 하나의 어플리케이션은 거대한 객체간의 협력을 의미하고 객체들은 서로 메세지를 통해 소통한다. 객체는 자율성이 있기 때문에 메세지를 수행하는 방법은 스스로 결정할 수 있다.

### 클래스와 인스턴스
클래스는 타입을 구현하는 도구이다. 타입은 객체를 분류하는 개념과 같은 말이다. 객체 간의 공통점을 뽑아내 개념을 만들 수 있다.
만약 개념을 어떤 객체에게 적용하면 그 객체를 분류한 것이다. 그 객체가 분류되면 개념 속에 들어가게 된다. 그 때 그 객체를 타입의 인스턴스라고 한다.

### 상속이란 무엇인가?
서브 타입이 슈퍼 타입의 기능과 속성을 물려받는 것을 의미한다. 상속이라는 의미이기 때문에 물려 받는다 적었지만 실제로는 서브 타입의 기능이 확장되는 것을 의미한다.

### 추상 클래스
- 클래스 내 메서드 중 추상 메서드가 있스는 클래스를 의미한다. 추상 클래스는 선언만 되고 구현은 안되어 있는 메서드를 의미한다. 구현은 추상 클래스를 상속한 서브 클래스에서 구현한다. 상속을 코드 상에서 구현하는 하나의 개념이다.<br>
- 추상 클래스는 추상메서드가 있기 때문에 인스턴스를 생성할 수 없다. 구현부가 없는 메서드가 존재하는 인스턴스를 생성할 수 없기 때문이다.

### 인터페이스
인터페이스는 두 사물간 경계에서 상호 작용할 수 있도록 도와주는 사물이다. 각 사물의 내부 동작 원리를 정확히 몰라도 상호작용할 수 있게 도와준다. 예를 들어, 자동차의 핸들을 통해 자동차와 상호작용할 수 있다. 자동차가 어떤 원리로 움직이는 지 모르지만 나는 핸들을 통해서 자동차를 동작할 수 있다.<br>
자바 문법에서 본 인터페이스는 클래스 내 메서드가 전부 추상 메서드인 클래스를 의미한다. 인터페이스를 사용하려면 서브 타입은 implements라는 키워드를 통해 인터페이스를 구현해야 한다.

### 메소드 오버로딩과 오버라이딩
메서드 오버로딩은 메서드의 매개변수 타입과 개수가 다르다면 메서드의 이름을 똑같이 쓰는 기능이다. 유사한 기능을 하는 메서드의 이름을 통일할 수 있어 코드 관리가 편해진다.

메서드 오버라이딩은 슈퍼 타입의 추상 메서드를 재정의하는 것을 의미한다. 추상 메서드는 선언만 되고 구현부가 없는 메서드이기 때문이다.

### 제네릭 선언법과 사용법
제네릭은 타입을 의미한다. 컬렉션의 인스턴스를 생성할 때 컬렉션의 타입을 지정할 수 있다. 컬렉션의 타입을 지정하면 컬렉션의 데이터는 지정한 타입으로 지정된다. 제네릭의 사용법은 <타입>으로 사용한다.

### 열거형의 사용법
열거형(Enum)은 상수를 효율적으로 관리할 수 있게 도와주는 문법이다. 과거 상수는 private static final라는 키워드로 사용해서 생성했다. 이후 인터페이스를 통해 private static final이라는 키워드를 생략하고 상수를 지정할 수 있었다. 그 때는 인터페이스명.상수이름으로 사용했다. 하지만 이 방식의 단점은 인터페이스와 상수명이 달라도 상수의 값이 같다면 두 상수를 구분할 수 없다. 다른 인스턴스의 상수는 값이 같더라도 구분이 필요해졌다.<br>
이 때 열거형이 등장한다. enum은 enum명.상수명으로 사용한다. 기존 상수 사용법과 차이점은 다른 enum 인스턴스는 명확하게 구분된다.

### 예외 처리
#### 예외란?
예외란 문법적인 오류가 아니라 프로그램이 실행되면서 정상적이지 않은 상황을 의미한다. 예를 들어, 사용자에게 2개의 숫자를 입력받고 더하는 프로그램이 있다. 하지만 사용자가 문자를 입력하면 문법의 오류는 아니지만 프로그램은 읽을 수 없는 상황이 발생한다.<br>
#### 예외 처리는 예외 클래스의 인스턴스를 처리하는 것
예외가 발생하면 발생한 지점(메서드)에서 예외 클래스의 인스턴스가 생긴다. 만약 발생한 곳에서 예외 인스턴스를 처리하지 못하면 그 메서드를 호출한 곳으로 예외 인스턴스를 전가한다. 결국 main메서드도 처리하지 못하면 가상머신이 처리하고 그 때 프로그램이 종료된다. 그 메세지를 자세히 보면 에러의 전달과정이 보인다(printStackTrace())<br>
#### 예외 처리 2가지 방법
- try - catch() : 예외가 발생할 수 있는 지점을 try{}로 묶은 뒤 만약 에러가 발생하면 예외 클래스의 인스턴스가 catch()의 인스턴스로 들어간다. catch()이후 코드는 실행된다.
- throw Exception : 현 메서드에서 발생하는 예외를 그 메서드를 호출한 상위 메서드에 전가한다. 만약 상위 메서드에서 예외 처리하면 프로그램은 문제없이 작동한다.

### 컬렉션 프레임워크
#### 컬렉션 프레임워크란
컬렉션 프레임워크는 여러 개의 데이터를 하나로 묶어주는 프레임워크다. 컬렉션 프레임워크가 있으면 다양한 데이터를 안전하고 편리하게 처리할 수 있다. 최상위 클래스는 Collection<>()이고 나머지 클래스는 Collection<>()를 구현한다. 대표적으로 ArrayList(), HashMap<>(), HashSet<>()이 99% 이상을 차지한다. 

#### 배열과 차이점
배열은 컬렉션 클래스를 상속하지 않는다. 배열은 처음 선언 후 초기화할 때 크기를 지정해줘야 한다. 컬렉션에 비해 기능이 부족하지만 정해진 개수의 데이터를 처리할 때 캡슐화가 되어 있어 안전하다.

### 내부 클래스(nested class), 중첩 클래스와 람다
Nested class는 한 클래스 내에서 정의된 클래스를 의미한다. 이중 static이 선언되지 않는 클래스를 이너 클래스라 한다. 이너 클래스는 멤버 클래스, 로컬 클래스, 익명 클래스로 나눠진다. 익명 클래스는 람다와도 연결된다. 익명 클래스를 간단하게 구현할 때 람다식을 사용한다. 

람다식은 컴파일러가 이해할 수 있는 수준만 코드를 줄이는 기법을 의미한다. 보통 익명 클래스를 람다식으로 줄일 수 있다. 람다를 통해서 객체를 메서드의 인자로 전달할 수 있다. 마치 일급 객체처럼 사용할 수 있게 됐다. 

### 스트림
스트림은 데이터의 흐름을 의미한다. 컬렉션 및 배열 인스턴스의 데이터를 편리하게 추출하고 사용하기 위해 만들어졌다. 스트림이 만들어지면 그 스트림이 중간연산, 최종연산이라는 파이프를 거치면 연산결과가 나온다. 그 과정을 연속해서 할 수 있기 때문에 유용하게 사용할 수 있다. 다만, 스트림은 값을 가져오는 것이 아니라 복사하는 것이기 때문에 최종연산을 거치면 닫혀서 다시 사용할 수 없다.

### Optional
#### Optional이란
Optional이란 모든 타입을 감쌀 수 있는 Wrapper 클래스를 의미한다. Optional 내 다양한 메서드가 있어서 null값 처리를 편리하게 도와준다.

### 날짜 처리
### IO 스트림
스트림은 데이터의 흐름을 의미한다. 그 중 IO 스트림은 입력과 출력을 유용하게 도와주는 자바의 객체이다. Input은 외부 데이터가 자바 프로그램으로 들어오는 것을 의미하고, Output은 자바 프로그램에서 외부로 데이터가 나가는 것을 의미한다. 자바에서 IO스트림은 기본적으로 바이트 단위로 읽는다.
모든 데이터는 컴퓨터 내에서 0과 1로 존재하기 때문에 바이트 단위로 입력과 출력하는 것이 유용하다. 추가로 자바에서는 문자를 효율적으로 다룰 수 있는 문자 스트림을 제공한다.

### 스레드와 동기화

### 함수와 메서드의 차이는? 
함수는 객체와 상관없이 존재할 수 있지만 메서드는 반드시 객체안에 존재해야 한다. 메서드는 객체가 책임을 수행하는 방법이기 때문이다.
